// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: gtfs-realtime-api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct GtfsRealtimeApi_ListVehiclePositionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Agency ID (UUID)
  var agencyID: String = String()

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var bufferSeconds: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct GtfsRealtimeApi_ListVehiclePositionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Agency ID (UUID)
  var agencyID: String = String()

  var vehiclePositions: [GtfsRealtimeApi_VehiclePosition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GtfsRealtimeApi_VehiclePosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID (UUID)
  var id: String = String()

  var tripID: String {
    get {return _tripID ?? String()}
    set {_tripID = newValue}
  }
  /// Returns true if `tripID` has been explicitly set.
  var hasTripID: Bool {return self._tripID != nil}
  /// Clears the value of `tripID`. Subsequent reads from it will return its default value.
  mutating func clearTripID() {self._tripID = nil}

  var routeID: String {
    get {return _routeID ?? String()}
    set {_routeID = newValue}
  }
  /// Returns true if `routeID` has been explicitly set.
  var hasRouteID: Bool {return self._routeID != nil}
  /// Clears the value of `routeID`. Subsequent reads from it will return its default value.
  mutating func clearRouteID() {self._routeID = nil}

  var directionID: Int32 {
    get {return _directionID ?? 0}
    set {_directionID = newValue}
  }
  /// Returns true if `directionID` has been explicitly set.
  var hasDirectionID: Bool {return self._directionID != nil}
  /// Clears the value of `directionID`. Subsequent reads from it will return its default value.
  mutating func clearDirectionID() {self._directionID = nil}

  var startDatetime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startDatetime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startDatetime = newValue}
  }
  /// Returns true if `startDatetime` has been explicitly set.
  var hasStartDatetime: Bool {return self._startDatetime != nil}
  /// Clears the value of `startDatetime`. Subsequent reads from it will return its default value.
  mutating func clearStartDatetime() {self._startDatetime = nil}

  var scheduleRelationship: String {
    get {return _scheduleRelationship ?? String()}
    set {_scheduleRelationship = newValue}
  }
  /// Returns true if `scheduleRelationship` has been explicitly set.
  var hasScheduleRelationship: Bool {return self._scheduleRelationship != nil}
  /// Clears the value of `scheduleRelationship`. Subsequent reads from it will return its default value.
  mutating func clearScheduleRelationship() {self._scheduleRelationship = nil}

  var vehicleID: String {
    get {return _vehicleID ?? String()}
    set {_vehicleID = newValue}
  }
  /// Returns true if `vehicleID` has been explicitly set.
  var hasVehicleID: Bool {return self._vehicleID != nil}
  /// Clears the value of `vehicleID`. Subsequent reads from it will return its default value.
  mutating func clearVehicleID() {self._vehicleID = nil}

  var vehicleLabel: String {
    get {return _vehicleLabel ?? String()}
    set {_vehicleLabel = newValue}
  }
  /// Returns true if `vehicleLabel` has been explicitly set.
  var hasVehicleLabel: Bool {return self._vehicleLabel != nil}
  /// Clears the value of `vehicleLabel`. Subsequent reads from it will return its default value.
  mutating func clearVehicleLabel() {self._vehicleLabel = nil}

  var vehiclePosition: GtfsRealtimeApi_Coordinate {
    get {return _vehiclePosition ?? GtfsRealtimeApi_Coordinate()}
    set {_vehiclePosition = newValue}
  }
  /// Returns true if `vehiclePosition` has been explicitly set.
  var hasVehiclePosition: Bool {return self._vehiclePosition != nil}
  /// Clears the value of `vehiclePosition`. Subsequent reads from it will return its default value.
  mutating func clearVehiclePosition() {self._vehiclePosition = nil}

  var currentStopSequence: Int32 {
    get {return _currentStopSequence ?? 0}
    set {_currentStopSequence = newValue}
  }
  /// Returns true if `currentStopSequence` has been explicitly set.
  var hasCurrentStopSequence: Bool {return self._currentStopSequence != nil}
  /// Clears the value of `currentStopSequence`. Subsequent reads from it will return its default value.
  mutating func clearCurrentStopSequence() {self._currentStopSequence = nil}

  var stopID: String {
    get {return _stopID ?? String()}
    set {_stopID = newValue}
  }
  /// Returns true if `stopID` has been explicitly set.
  var hasStopID: Bool {return self._stopID != nil}
  /// Clears the value of `stopID`. Subsequent reads from it will return its default value.
  mutating func clearStopID() {self._stopID = nil}

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tripID: String? = nil
  fileprivate var _routeID: String? = nil
  fileprivate var _directionID: Int32? = nil
  fileprivate var _startDatetime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _scheduleRelationship: String? = nil
  fileprivate var _vehicleID: String? = nil
  fileprivate var _vehicleLabel: String? = nil
  fileprivate var _vehiclePosition: GtfsRealtimeApi_Coordinate? = nil
  fileprivate var _currentStopSequence: Int32? = nil
  fileprivate var _stopID: String? = nil
  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct GtfsRealtimeApi_Coordinate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latitude: Float = 0

  var longitude: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension GtfsRealtimeApi_ListVehiclePositionsRequest: @unchecked Sendable {}
extension GtfsRealtimeApi_ListVehiclePositionsResponse: @unchecked Sendable {}
extension GtfsRealtimeApi_VehiclePosition: @unchecked Sendable {}
extension GtfsRealtimeApi_Coordinate: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "gtfs_realtime_api"

extension GtfsRealtimeApi_ListVehiclePositionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListVehiclePositionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "agency_id"),
    2: .same(proto: "timestamp"),
    3: .standard(proto: "buffer_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.agencyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.bufferSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.agencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.agencyID, fieldNumber: 1)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.bufferSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.bufferSeconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GtfsRealtimeApi_ListVehiclePositionsRequest, rhs: GtfsRealtimeApi_ListVehiclePositionsRequest) -> Bool {
    if lhs.agencyID != rhs.agencyID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.bufferSeconds != rhs.bufferSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GtfsRealtimeApi_ListVehiclePositionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListVehiclePositionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "agency_id"),
    2: .standard(proto: "vehicle_positions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.agencyID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.vehiclePositions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.agencyID.isEmpty {
      try visitor.visitSingularStringField(value: self.agencyID, fieldNumber: 1)
    }
    if !self.vehiclePositions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vehiclePositions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GtfsRealtimeApi_ListVehiclePositionsResponse, rhs: GtfsRealtimeApi_ListVehiclePositionsResponse) -> Bool {
    if lhs.agencyID != rhs.agencyID {return false}
    if lhs.vehiclePositions != rhs.vehiclePositions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GtfsRealtimeApi_VehiclePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehiclePosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "trip_id"),
    3: .standard(proto: "route_id"),
    4: .standard(proto: "direction_id"),
    5: .standard(proto: "start_datetime"),
    6: .standard(proto: "schedule_relationship"),
    7: .standard(proto: "vehicle_id"),
    8: .standard(proto: "vehicle_label"),
    9: .standard(proto: "vehicle_position"),
    10: .standard(proto: "current_stop_sequence"),
    11: .standard(proto: "stop_id"),
    12: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._tripID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._routeID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._directionID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._startDatetime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._scheduleRelationship) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._vehicleID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._vehicleLabel) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._vehiclePosition) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self._currentStopSequence) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._stopID) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._tripID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._routeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._directionID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._startDatetime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._scheduleRelationship {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._vehicleID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._vehicleLabel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._vehiclePosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._currentStopSequence {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._stopID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GtfsRealtimeApi_VehiclePosition, rhs: GtfsRealtimeApi_VehiclePosition) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._tripID != rhs._tripID {return false}
    if lhs._routeID != rhs._routeID {return false}
    if lhs._directionID != rhs._directionID {return false}
    if lhs._startDatetime != rhs._startDatetime {return false}
    if lhs._scheduleRelationship != rhs._scheduleRelationship {return false}
    if lhs._vehicleID != rhs._vehicleID {return false}
    if lhs._vehicleLabel != rhs._vehicleLabel {return false}
    if lhs._vehiclePosition != rhs._vehiclePosition {return false}
    if lhs._currentStopSequence != rhs._currentStopSequence {return false}
    if lhs._stopID != rhs._stopID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GtfsRealtimeApi_Coordinate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Coordinate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude != 0 {
      try visitor.visitSingularFloatField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularFloatField(value: self.longitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GtfsRealtimeApi_Coordinate, rhs: GtfsRealtimeApi_Coordinate) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
